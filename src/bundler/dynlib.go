package bundler

import (
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"strings"

	"../config"
)

var luaLoaderFunc = `-- This function generated by LuBu. Used to load dll modules
local function createAndLoadDll(name, binary)
    local moduleName = name;
    local function getSelfPath()
        for path in package.cpath:gmatch('([^;]+)') do
            return path;
        end
        return nil;
    end
    
    local path = getSelfPath();
    assert(path, '[LuBu] Unable to get path for temp DLL file');
    local path = path:gsub('?.dll', moduleName .. '.dll');
    
    local tempDll = io.open(path, 'wb');
    assert(tempDll, ('[LuBu] Unable to create temp DLL file \"%s\"'):format(path));
    tempDll:write(binary);
    tempDll:close();

    local loadedModule = require(moduleName);
    --os.remove(path);
    return loadedModule;
end
`

func GenerateDll(config config.Config) string {
	list := []string{"-- DLLS"}
	for moduleName, filePath := range config.Dll {
		log.Printf("[DLL] Bundling \"%s\" from \"%s\"\n", moduleName, filePath)
		if len(list) == 0 {
			list = append(list, "-- LuBu Bundled DLLs\n"+luaLoaderFunc)
		}
		list = append(list, WriteDll(moduleName, filePath))
	}
	return strings.Join(list, "\n\n")
}

func WriteDll(moduleName, filePath string) string {
	bytes, err := os.ReadFile(filePath)
	if err != nil {
		log.Panicf("[DLL][ERROR] Error reading resource %s: %s", filePath, err.Error())
	}
	byteAsLuaString := []string{}
	for index := range bytes {
		byteAsLuaString = append(byteAsLuaString, "\\x"+strings.ToUpper(hex.EncodeToString(bytes[index:index+1])))
	}
	return fmt.Sprintf("-- Dll Module %s (%s)\npackage.preload['%s'] = createAndLoadDll('%s', [[%s]]);", moduleName, filePath, moduleName, moduleName, strings.Join(byteAsLuaString, ""))
}
